v4 <- seq(0.1,1.0,0.1)
print(v4)

v5 <-rep(1,times=5)
v5

v6<- rep(1:5,times=3)
v6

v7<-(rep(c(1,5,9),times=3)) #c는 백터를 만들어 주는 함수. 
v7

#3. 백터의 이해 - 벡터이 원소값에 이름 지정
score <- c(90,85,70) # 성적
score
names(score) #score에 저장된 값들의 이름을 보이시오
names(score) <- c("john","tom","jane") # 인덱스에 이름 붙히는 것처럼 이해하면 될듯

score

#4. 벡터에서 원소값 추출
d<-c(1,4,3,7,8)

d[1]  #r은 인덱스 1부터 시작함.
d[2]
d[3]
d[4]
d[5]


#4-1. 벡터에서 여러 개의 값을 한번에 추출하기

d <- c(1,4,3,7,8)

d[c(1,3,5)] # 1,3,5 번째 출력

d[1:3] # 처음 세개의 값 출력

d[seq(1,5,2)] #홀수 번째 값 출력

d[-c(3,5)] #3~5 번째 값은 제외하고 출력  , - => 원하는 인덱스를 제외하고


#4-2 벡터에서 이름으로 값을 추출하기

GNP <- c(2090,2450,960)
GNP
names(GNP) <- c ("Korea","Janpan","Nepal")
GNP
GNP[1]  #인덱스로
GNP["Korea"] # 코리아 라는 이름으로 찾기
GNP[c("Korea","Nepal")]  #벡터 사용해서 코리아 네팔을 찾기



#5. 벡터에 저장된 원소 값 변경

v1 <- c(1,5,7,8,9)
v1
v1[2] <-3 #2번째 값을 3으로변경 
v1

v1[c(1,5)] <-c(10,20) #첫번째 다섯번째 값을 10과 20으로 변경
v1





#Section 벡터의 연산!!! 4
#4-1 벡터와 숫자값 연산

d <-c(1,4,3,7,8)
2*d
d-5
3*d + 4

#4-2 벡터오 ㅏ벡터 간의 연산

x<-c(1,2,3)
y<-c(4,5,6)

x+y #대응하는 원소끼리 더하여 출력
x*y # 대응하는 원소끼리 곱하여 출력
z<-x+y #x,y를 더하여 z에 저장
z



d<-c(1,2,3,4,5,6,7,8,9,10)
sum(d)
sum(2*d)
length(d)
mean(d[1:5])
max(d)
min(d)
sort(d)
sort(d,decreasing = FALSE)#오름차순
sort(d,decreasing = TRUE) #내림차순




#4-4 코드에 논리연산자 적용

d<-c(1,2,3,4,5,6,7,8,9)
d>=5
d[d>5] #5보다 큰값
sum(d>5) #5보다 큰값의 갯수
sum(d[d>5]) #5보다 큰 값의 합계를 출력
d==5


condi <-d >5 & d< 8 # 조건을 변수에 저장 
d[condi]        # 조건에 맞는 변수 선택


#5 리스트와 팩터 
# 5-1 리스트 : 서로다른 자료형의 값들을 1차원 배열에 저장하고 다룰 수 있도록 해주는 수단

ds <-c(100,25,70,84)
my.info<- list(name='jihwan',age=24,status=TRUE,score=ds)
my.info #리스트에 저장된 값 출력
my.info[[1]]
my.info$name #리스트에서 값의 이름이 name인 값을 출력
my.info[[4]]




#5-2 팩터 : 문자형 데이터가 저장된 벡터의 일종

#예를 들어 성별, 혈액형, 선호 정당 등과 같이 저장할 문자값들이
#몇종류로 정해져 있을 때 팩터를 사용

bt<-c('A','B','B','O','AB','A' ) # 문자형 벡터 bt 정의
bt.new<-factor(bt) # 팩터 bt.new 정의
bt
bt.new

bt[5]
bt.new[5]

levels(bt.new) #팩터에 저장된 종류를 출력

as.integer(bt.new) #levels 기준으로 숫자로 각 문자를 출력

bt.new[7] <- 'B'
bt.new[8] <- 'C' #팩터는 처음 선언할때 만들었던 레벨즈만 쓸 수 있다.
                 #즉 C는 추가적으로 못 넣는다

bt.new



